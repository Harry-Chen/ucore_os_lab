# uCore Lab2 实验报告

## 练习1：实现 first-fit 连续物理内存分配算法

这个联系要求在 `default_pmm.c` 中实现 first-fit 的连续内存分配算法，其核心思想为维护一个空闲区块的双向链表 `free-list`，其中各节点地址递增，记录了一片（尽可能长）的空闲物理内存。我们需要修改 `alloc_pages` 和 `free_pages` 函数，正确实现内存页面的分配和释放。

### 内存分配

分配算法的思想是遍历 `free_list`，找到第一片大于所需页面大小的空闲空间，并从它上面摘下申请的页面作为申请结果。事实上的效果等同于将连续空间切分为了两块，而在从链表中移除分配的空间之前，需要先将剩余的空余块插入在其之后。给出的实现中直接插入在最后，需要修改。同时，在分配内存时，也需要清空页面的 `pg_property` 属性，将其标记为已分配。

### 内存释放

释放相比分配比较复杂一些，因为可能涉及到多片连续空闲空间的合并。对于给定的需要释放的页面 `base`，寻找其在链表中的正确位置。做法为遍历链表，对于每一项 `p`，进行判断：

* 如果情况类似 `base(a) p(b)` 恰好相邻（中间没有空余空间），则从列表中移除 `p`，将 `base` 的大小扩大到 `a+b`
* 如果情况类似 `p(b) base(a)` 恰好相邻，则令 `base` 为 `p`，并将 `p` 的大小扩大到 `a+b`（类似于以 `p` 下一个节点为链表头，试图释放大小为 `a+b` 的空间）
* 继续直到 `p` 跑遍整个链表

此时，所有可能的空余块合并已经完成，只需再次遍历链表，找到 `base` 的合适位置插入即可。要注意如果没找到，则说明 `base` 刚好应该在最后。

事实上，这个算法可以进行优化。我们可以知道，如果每次真正合并了所有空闲块，则在释放时至多需要合并连续的三块空闲地址（即 `base` 和可能与其相邻的两块）。因此，其实不需要每次都遍历完整个链表完成合并。一旦找到相邻的情况，就可以进行特殊判断完成合并。这样，至多完整遍历一次链表（`base` 刚好在所有空闲块之后），就能完成释放。

## 练习2：实现寻找虚拟地址对应的页表项

寻找页表项对应的是 `pmm.c` 中的 `get_pte` 函数。首先，根据虚拟地址找到一级页表目录。如果它对应的页表不存在（没有 `PTE_P` 标志），说明需要新建页表。新建页表的过程为分配一个页、增加其引用数、将整个页表内容填充为0，并在页表目录中添加对于这个页表的索引。需要注意的是，分配的页地址为物理地址，而填充时已经需要使用虚拟地址，所以需要用 `KADDR` 宏进行转换。而添加索引时，除了页表地址外，也需要添加相应的标志位（存在、可读、用户可访问）。

X86架构的页目录项长度为 32，构成为:

```
 31           12   9
+---------------+---+-+-+-+-+-+-+-+-+-+
|   Page Base   |AVL|G|S|0|A|C|T|U|W|P|
+---------------+---+-+-+-+-+-+-+-+-+-+
```

其中各项含义为：

* Page Base: 页面对应物理地址的高 20 位
* AVL：可供用户使用，处理器不关心
* G：无用
* S：页大小，1 代表 4MB，0代表 4KB，uCore 使用 0
* A：页面是否被访问过
* C：是否缓存
* T：缓存是否 Write-Through
* U：页表中的页面是否允许用户访问
* W：是否可写
* P：页面是否存在

页表项长度也是 32，构成为：

```
 31           12   9
+---------------+---+-+-+-+-+-+-+-+-+-+
|   Page Base   |AVL|G|0|D|A|C|T|U|W|P|
+---------------+---+-+-+-+-+-+-+-+-+-+
```

其中各项含义为（只叙述与页目录项不同的）：

* G：是否为全局页表（在页表改变时可在保留在 TLB 中）
* D：是否被写过（脏页）
* U：该页是否允许用户访问

上述的两个结构中，如果 `P` 为0，代表该项不在主存中（比如被换出），此时其他项都没有意义，可以用于保存一些辅助的信息。

在 uCore 执行过程中访问虚拟地址时，如果出现页访问异常，则地址会被保存在 `CR2` 寄存器中，并通过 `IDT` 调用对应的中断处理例程。此时，通过 `error` 和 `eflags` 可以得到关于错误的更多信息，如原因（缺页/非法）和类型（读/写）。当前 uCore 并没有对这些异常的处理机制，会直接崩溃。对于一个虚拟内存管理完善的操作系统，此时可以进行换入页面/复制页面/杀死程序等处理。

## 练习3：释放某虚地址所在的页并取消对应二级页表项的映射

释放页比查询的操作要简单。如果页表项存在（`PTE_P` 置位），则将该物理页面的引用数减一，如果减到0，则还需要释放这个页面。而后清空页表项，并调用现成的函数将 TLB 对应项（如果有）清除即可。

通过页表项，能够得到物理页号，从而能够访问 `Page` 数组中对应的元数据（`pte2page`）；而通过任意一个 `Page` 的指针，也可以得到其物理页号（通过相对数组首地址偏移，使用 `page2pa` 宏），从而进行读写或者填入页表项中（通过 `KADDR` 转换为虚拟地址后）。

如果需要虚拟地址与物理地址相同，`KERNBASE` 需要改为 `0x00000000`，同时链接脚本内核加载地址需要改为 `0x00100000`。在 `check_pgdir` 中也不再清除最小的页目录项（否则映射会被清除）。事实上，没有必要建立第二个页表项，只需要保留直接映射的项目即可。

## 参考答案对比

我的实现与参考答案基本一致。在查询页表项的新建环节中，忘记将物理地址转换为虚拟地址从而导致运行错误，调试并参考答案后定位到了问题。此外，参考答案将减少页面引用和判断是否需要释放的操作合并，可能能够避免重复释放问题。但目前页面的释放者只有一处，因此不至于导致问题。

## 总结

本实验中涉及到 OS 课程比较重要的知识点有：

* first-fit 物理内存分配算法
* X86 的二级页表机制

还有没有涉及到的知识点有：

* best-fit, worst-fit 物理内存分配算法
* 反转页表技术
* 物理内存的碎片整理

此外，我阅读了扩展联系要求实现的 Buddy 内存管理算法实现，来自 [ucore-thumips](https://github.com/Harry-Chen/ucore-thumips/blob/trivial_mips/kern/mm/buddy_pmm.c) 项目。这种算法将内存切分为 2 的幂大小，能够做到高效的空间利用和快速的分配释放，是比较优越的内存管理算法。
