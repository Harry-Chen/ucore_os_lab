# uCore Lab3 实验报告

## 练习1：给未被映射的地址映射上物理页

在发生缺页异常后，如果访问的虚拟地址的确是用户有权限访问并且没有映射的，则需要在页表中添加这个映射，这些处理均在 `do_pgfault` 函数中完成。

首先通过 Lab2 中实现的 `get_pte` 函数找到对应的页表项，如果没有允许创建。如果页表项为空，说明尚未分配过物理页，则调用 `pdgir_alloc_page` 分配一个页面。否则，说明页面分配过但是被换出了，则需要使用 `swap_in` 函数将页面换入，并重新设置对应页表项、将页面标记为可换出的，并在 `Page` 中标记虚拟地址（这事实上已经完成了练习2的内容）。

根据 Lab2 实验报告中的叙述，当页表项和页目录项最后一位（PRESENT）为 0 时，代表页不存在于内存中，其高位不为 CPU 关心。因此，当页面被换出后，其他位可以用于存储关于交换分区的信息，本次实验中就存储了页的虚拟地址（对应了在硬盘上的位置）。而当项目最后一位为 1 时，还有 D、A 两位，标记了页面在初始化（分配/换入）后是否被写/访问过，这就给页面替换算法提供了换出页面的依据。

如果在页错误处理程序中又发生了页错误，则依旧会像在其他代码中发生页错误一样进入异常服务程序转到页错误处理函数，不同的是不会发生特权级切换。事实上，一个鲁棒的操作系统不应该在任何时候将内核使用的内存页面换出，因此这是不该发生的。

特别地，如果在发生页错误，CPU 试图处理时又发生了页错误（比如访问 IDT 指向的处理程序地址导致页错误），这会被处理器认为是双重错误 （Double Fault），并跳转到双重错误处理程序。一般而言双重错误是不可恢复的，系统应该关闭对应的程序。如果再次触发页错误，则是 Triple Fault，会直接导致处理器重置。

## 练习2：补充完成基于FIFO的页面替换算法

基于 FIFO 的页面替换算法非常简单，只需要使用链表，每次换出头部的一页，并将新换入的页连接到链表尾部即可。具体的实现在 `swap_fifo.c` 的 `_fifo_map_swappable` 和 `_fifo_swap_out_victim` 函数中，在后一个函数中，还需要返回被换出的页对应的 `Page` 对象地址，以便于实际的换页工作。与页面替换算法无关的其他工作，如修改页表、记录位置、读写磁盘等，均由 `swap.c` 中的各个函数实现，在本实验中不用修改。

在缺页处理程序 `do_pgfault` 中的部分，已经由练习1顺便完成了。

### 设计扩展时钟替换算法

得益于 swap manager 解耦合的设计，其不需要任何实质修改就能与扩展时钟替换算法协同工作，只需要将其中的算法实现更换即可。
在内存分配的部分，与 FIFO 算法没有区别。即在每次 `map_swappable_page` 被调用时，就将对应的物理页面加入双向链表中即可。

而在内存换出的部分，即 `swap_out_victim` 函数中，需要按照描述实现扩展始终替换算法。即，维护一个“时钟”指针，不断地遍历整个链表，直到找到可以换出的页面。核心判断逻辑如下：

1. 读取指针指向的物理页面对应的虚拟地址的页表项，判断 A（被访问） 和 D（被写入） 两个位
2. 若 A = D = 0，换出这一个页面（不需要写入 swap），将指针后移一项，退出算法
3. 若 A = 0， D = 1，将页面写入 swap 文件后清除 D 位、刷新 TLB，指针后移
4. 若 A = 1，则清零 A 并刷新 TLB，指针后移

根据上述的算法，可以保证换出页面的次序与课程文档中介绍的完全一致。事实上被换出的页面总是 A=D=0 的，处于其他状态的页面总是先被转换到此状态，并在这个转换过程中得到应有的处理（如写回/刷新TLB）。

## 参考答案对比

与参考答案对比，我本次的实现中都没有考虑到各种失败的可能（包括分配页面、写入磁盘等），因此我根据答案为这些操作都加上了错误判断和处理。为了系统的鲁棒性，错误处理是必要的。

## 总结

本实验中涉及到 OS 课程比较重要的知识点有：

* LILO 页面替换算法
* 时钟、扩展时钟页面替换算法
* 虚拟地址到物理地址映射的建立（页表的填写）

还有没有涉及到的知识点有：

* LRU 页面替换算法
* Belady 现象（可增加实验）
* 内存覆盖

