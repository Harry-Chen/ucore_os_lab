# uCore Lab5 实验报告

## 练习0: 填写已有实验

一些需要修改的地方为：

* `do_fork` 时调用 `set_links` 设置进程归属关系，并设置进程控制块到父进程控制块的指针
* 在时钟中断触发时将当前进程的 `need_resched` 置为 1，使其主动出让资源，调度其他进程

## 练习1: 加载应用程序并执行

在 `load_icode` 函数中，拷贝 ELF 文件的到内存后，还需要设置新进程的 trapframe，以让它正确地开始执行。除了各个段选择子，`EIP` 和 `ESP` 地正确设置是很关键的，按照注释写出即可。

当应用程序被标记为 `RUNNING` 后，首先 `proc_run` 函数被调用，`current` 被指向当前的进程；然后该进程的页表被加载到 `CR3` 寄存器中，并通过 `switch_to` 函数恢复上下文（此时没有真正的恢复，而是置于初始状态），并跳转到 `forkret` 中。而后，由 `__trapret` 进行异常返回，切换特权级和上下文，跳转到用户态代码，开始执行。

## 练习2: 父进程复制自己的内存空间给子进程

`copy_range` 函数中需要补充的地方为将一个页从父进程的内存空间复制到子进程中，只需要正确获得它们对应的内核态虚拟地址，并调用 `memcopy` 进行复制即可。

对于 CoW，这是一个比较复杂的特性。在 `copy_range` 函数中，如果参数 `share` 置位，说明并不需要真正复制内存，只需要使用原有的物理页面即可，只需要在新进程页表中插入对应的页表项，但是此时 W 标志需要设置为 0。而后，如果父/子程序对这些内存有写操作，则会触发页错误，此时再对页进行复制，并将新页面置为可写的即可。需要注意的是，对于原有页面和新复制页面的引用计数要分别维护，防止出现内存的泄露。

## 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现

### `fork`

`fork` 新建了一个进程控制块，并将当前进程的所有信息复制到新进程中（包括内存空间）。

### `exec`

`exec` 将当前进程的内存清空，然后将指定的 `ELF` 文件的代码段复制到指定内存中（如有需要，进行内存的映射和分配）。

### `wait`

`wait` 在调用时，如果该进程有子进程并且处于非 `ZOMBIE` 状态，则进程主动休眠；否则，清理子进程的资源，并得到子进程函数的返回值。如果没有子进程，则直接返回一个错误。

### `kill`

`kill` 会给目标进程打上 `EXITING` 的标记并唤醒进程，当进程下一次被调度到时，它就会调用 `exit` 系统调用来让自己退出。

### `exit`

`exit` 系统调用会清理当前进程的资源（如内存），然后与其所有子进程脱离（将它们的父进程设置为 `init`），自己进入 `ZOMBIE` 状态。该进程的父进程接下来会负责剩余的清理工作（包括内核栈、进程控制块）。

对于进程各个状态的转换关系，由于尝试几次排版均不够美观，uCore 注释中的图也并不直观，我的实验报告中借用并修改了上一届谭闻德同学绘制的 ASCII 状态转移图（经过本人授权）：

```text
 N/A   +- (5) --- RUNNING --------------+
  |    |           A    |               |
  |    |           |    |               |
 (1)   |          (3)  (4)             (7)
  |    |           |    |               |
  V    |           |    V               V
UNINIT -- (2) --> RUNNABLE -- (7) --> ZOMBIE -- (8) --> N/A
       |             A                  A
       |             |                  |
       |            (6)                (7)
       |             |                  |
       |             |                  |
       +- (5) --> SLEEPING -------------+
```

其中各个边上的转移触发条件为：

1. `alloc_proc`
2. `wakeup_proc`
3. `proc_run` 的被调用者
4. `proc_run` 的调用者
5. `wait` 或者 `sleep` 系统调用
6. `wait` 系统调用成功返回
7. 调用 `exit`
8. 父进程 `wait` 该进程返回，资源被清理

## 与答案对比

很遗憾，在实现过程中，我一度把 `copy_range` 函数中 `memset` 的目标和源写反了，导致无法成功进行 fork。通过与答案的二分对比和 gdb 的调试，我最后定位并修复了这一个错误。

其余实现由于注释非常详细，基本与答案一致。

## 总结

本实验中涉及到 OS 课程比较重要的知识点有：

* 用户进程的状态管理与转换
* Copy on Write