# uCore Lab8 实验报告

## 练习0：填写已有实验

除了填入对应的代码外，还需要在 `proc.c` 的 `do_fork` 函数中，使用 `copy_files` 函数将父进程打开的文件信息复制到子进程中。

## 练习1: 完成读文件操作的实现

### 文件区间读写的实现

需要完成的部分是对数据的实际读写，一共有两个函数可以完成操作，`sfs_buf_op` 用于一个块内的非对其读写，`sfs_block_op` 用于整个块的对齐读写。在每次读写某个块前，都需要使用 `sfs_bmap_load_unlock` 函数，将文件系统中的逻辑块号转换为硬盘的物理块号（因为逻辑上连续的块号在物理上并不一定连续）。

首先，我实现了一个 `READ_ALIGNED` 宏，能够从指定的块号和偏移处读取指定大小的数据（需要起始和结束都在同一块内）。这是因为每次读取都有很多相同的操作（如映射、检查、自增读取尺寸等），写成宏能够减少冗余代码量。

请求的地址是连续的一片 `[offset, endpos)`，我们首先将 `offset` 和 `endpos` 分别向上和向下按块大小取整，得到 `align_begin` 和 `align_end`。如果这两者都在一块中并且都不是边界，那么会导致 `align_begin > align_end`，我们单独处理这个情况，只需要进行一次非对齐读取即可。否则，我们总是可以将区间分为三份：`[offset, align_begin), [align_begin, align_end), [align_end, endpos)`，其中中间一段是完全对齐的，而三段的长度总是不小于0。在实现时，只需要对起始和结束的非对称部分进行非对齐读写，中间部分循环进行对齐读写即可。读写前需要检查每段长度是否大于0，不是则直接跳过，避免额外的开销。

需要注意的是，每一次操作都需要检查返回值，出错则跳转到相应处理代码。最后返回的长度是实际进行的读写量。

### UNIX 的 PIPE 机制实现设计

`PIPE` 与普通文件不同，它对应着一段指定长的内存的缓冲区，一段只能读，一段只能写，并且在读 / 写不能被满足时，相应进程需要被阻塞。下面是一些简单的实现描述：

#### 创建与关闭

创建 `PIPE` 时，需要在 VFS 层建立一个类型为管道的 inode，并新建两个打开的文件结构体和文件描述符指向这个 inode，一个只写，一个只读。同时，需要在 inode 上绑定用户指定长度的缓冲区。而后，将这两个描述符返回给用户。

关闭管道时，如果有线程被阻塞在其上，则应该被唤醒，并告知其读写操作失败。而后，inode 和对应的缓冲区都需要被释放。

#### 读写操作

`PIPE` 的读写操作实现并不复杂，系统需要维护管道当前现存数据大小和剩余大小两个量，而读写操作本质上对应在缓冲区和用户给定数据之间的复制。对于写入者，只有写入大小不大于剩余大小时，操作能够立刻返回，否则，它将开始睡眠；只要写入了数据，则系统就会唤醒正在睡眠的读取者（如果有）。而对于读取者，只有读取大小不大于现存数据大小时，操作能够立刻返回，否则，它将开始睡眠；只要读取了数据，则系统就会唤醒正在睡眠的写入者（如果有）。

上述的设计，再加上关闭管道时的处理，能够保证不会出现两方同时被阻塞的现象。

## 练习2: 完成基于文件系统的执行程序机制的实现

### 程序执行的实现

对于 `load_icode` 函数，首先大部分之前实验中的代码均可直接复用，但需要将所有通过 `binary` 指针的操作变为从给定的 `fd` 中读取相应大小的数据即可。不过需要注意一些 `offset` 的计算发生了变化，如不再能直接通过指针来遍历 ELF 程序节头，而是需要通过编号拷贝出相应的结构体来进行。

另一个变化是用户程序启动时需要得到参数，按照 `main` 函数的调用约定应该是 `int argc, char *argv[]`，这需要这个函数把参数从内核态复制到用户的栈上。由于在分配物理内存后就加载了对应进程的页表到 `CR3` 寄存器，因此直接从 `USTACKTOP` 对应的地址向下开始写入参数信息即可。

首先需要将 `argv` 中每个字符串的内容都复制到栈上，需要注意最后填上 `\0`，并存下每个字符串的起始地址指针，把这些指针按照参数顺序写入临时数组 `char* uargv[]` 中，并在所有参数后填充一个空指针表示参数结束。接着将当前栈底地址按照字对齐，从高往低逆序写入 `uargv` 的内容，然后再写入 `argc`，这样就完成了用户栈的构造。最后用户态开始执行时的 `ESP` 内容应该是 `argc` 被拷贝到的地址，`main` 函数就能够正常读取它的参数了。

### UNIX 的软硬链接实现机制

#### 硬链接

硬链接事实上是对 inode 的引用，即链接的目标和链接本身是平等的。只需要在创建文件项时，将其 inode 号赋值为被链接文件的 inode 号，并增加 inode 的引用计数即可。需要注意的是，删除文件时首先减少 inode 的引用计数，如果没有归零，则不进行实际 inode 和数据的清空等操作。

#### 软链接

软链接的本质是文件，一种简单的实现是将 inode 类型表记为链接，在文件内容中写入目标即可。需要注意的是，在进行文件的查找、打开等操作时，如果遇到软链接，都需要进行间接的查找，对链接的目标而不是链接本身进行操作。

## 参考答案对比

本次实验由于注释并不详细到每一个函数调用，所以我与参考答案的实现有一定的出入，但大体上语义是一致的。有三点不同之处：

* 答案在 `load_icode` 中读取完文件后关闭了文件，而我没有，可能导致资源泄露。
* 答案在 `load_icode` 中加入了较多错误处理。
* 答案读取文件的写法比较简要，统一处理了我分的两种情况。

## 总结

本实验中涉及到 OS 课程比较重要的知识点有：

* 虚拟文件系统（VFS）
* 文件描述符
* inode、打开的文件结构

还有没有涉及到的知识点有：

* 磁盘调度算法
* 外设 IO

本实验是 uCore 的最后一个 Lab，不得不说用两周的时间自己完成八个实验的确是一种挑战。在这个过程中，我踩了很多坑，也学习到了很多。