# uCore Lab7 实验报告

## 练习0：填写已有实验

需要将 `trap.c` 中时钟中断处的 `sched_class_proc_tick` 修改为 `run_timer_list`，这个函数处理了内核中的各个定时器，随后调用了 `sched_class_proc_tick`。

我还修复了 Lab6 中实现的调度算法带来的一个 bug，可见对应的实验报告。

## 练习1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题

### 内核信号量的实现

内核中信号量的实现都在 `sem.c` 中，其中使用的主要数据结构是 `wait_queue_t`，本质是基于链表实现的一个队列。它提供的接口主要如下：

#### `sem_init`

初始化一个信号量，赋为用户给定的值，并初始化这个信号量对应的队列。

#### `down`

这在信号量原语中对应 `P`。进入时首先进入临界区，如果目前的值大于0，则减少信号量后直接退出临界区并返回；否则进程将自己放入等待队列中（进入 `SLEEPING` 状态），退出临界区，主动调用 `schedule` 放弃时间片。当进程继续执行时，意味着它被其它进程释放的信号量所唤醒，此时进程在临界区中将自己移出等待队列并返回。总之，当这个函数返回时，保证进程总是成功地获得了对应的信号量。

uCore 的实现中还设置了 `wakeup_flags`，即进程唤醒可能并不总是由于信号量的释放，但也保证了目前调用 `down` 时一定不会被这样唤醒。

#### `try_down`

这个函数用来进行“进程不想等待”的 `P` 操作，即如果不需要等待即可获取信号量，则获取，否则直接返回失败。

#### `up`

这在信号量原语中对应 `V`。首先进入临界区，如果等待队列中没有进程，则直接增加信号量的值；否则就唤醒一个等待进程并不改变值（因为本进程 +1，等待进程 -1，两者刚好抵消）。完成上述操作后，退出临界区。

### 用户态信号量的实现

事实上，这是一个典型的需求，即将一个内核服务提供给用户态。首先，需要声明新的系统调用来分配、操作和销毁信号量。由于需要隔离两个特权级的内存，最简单的实现是在内核中维护一个信号量池（可以是全局的也可以是每个进程的，利用进程的内核栈），每次给用户分配信号量时，只能返回一个索引（类似 `file descriptor`），而用户总是使用这个索引值来完成对信号量的其余操作。对于请求的转发是比较简单的，与其他系统调用是类似的。

## 练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题

### uCore 中条件变量的实现

uCore 中条件变量和管程都利用信号量进行实现，位于 `monitor.c` 中，类似课程中的 Hoare 管程。代码中的注释已经非常详细地说明了应该进行的操作，简单叙述如下：

#### `monitor_init`

这个函数用于初始化一个管程，包括给它分配指定数量的信号量，以及初始化互斥锁等。

#### `cond_signal`

如果有线程正在等待这个条件变量，则自增 `next_count`（表示当等待者结束后还需要执行的进程计数），释放条件变量对应的信号量 `sem`，让等待者获得管程控制权。然后尝试获得 `next` 信号量，即等待到前一进程结束再获得管程控制权，最后减小 `next_count`，表明 `signal` 已经完成。

#### `cond_wait`

首先自增条件变量的 `count`，表示将被阻塞的线程数量。如果有正在执行 `signal` 的线程阻塞，则唤醒这个进程，否则释放管程的互斥锁；而后试图获取 `sem` 信号量以让自己等待 `signal` 进程的唤醒。一旦被唤醒，减小 `count`，表示 `wait` 已经完成。

### 哲学家就餐问题中条件变量的使用

除了管程的实现，在 `check_sync.c` 中还需要添加代码才能使用条件变量：

#### `phi_test_condvar`

这个函数检查某个哲学家是否能就餐，如果能，则开始就餐，并且 `signal` 自己对应的条件变量。

#### `phi_take_forks_condvar`

这个函数用于让某位哲学家拿起叉子。首先获得管程互斥锁进入管程，然后将自己标记为饥饿状态，并调用上面的检查函数，如果检查失败，则在自己对应的条件变量上进行 `wait`。一旦被唤醒，说明自己已经成功就餐（见下面的函数实现），释放互斥锁或者唤醒等待的 `signal` 线程，释放管程控制权。

#### `phi_put_forks_condvar`

这个函数用于让某位哲学家放下叉子。首先进入管程，标记自己为就餐完毕状态，并检查左右两侧的哲学家是否能就餐。此时只要有人满足条件，当前哲学家线程就会让他就餐，并 `signal` 对应的条件变量，释放管程让自己开始等待，等到他就餐完毕后才回到当前线程。最后同样释放管程控制权。

### 用户态条件变量的实现

可以考虑两种方案：

* 将条件变量的逻辑全部实现在用户态，调用上文提到的信号量对应 API
* 将条件变量也按照类似上面的方法设计为系统调用（包括初始化、释放、`wait`、`signal`）

### 不使用信号量实现条件变量

由于信号量本身使用等待队列实现，因此自然可以只通过等待队列和互斥锁（不借助信号量）来实现条件变量。简单来说，只需要将对应的信号量 `up` 和 `down` 操作替换为条件变量的内部实现即可。我们也可以简化流程，不需要完全进行替换：

#### `cond_wait`

1. 进入临界区，释放互斥锁
2. 将自己标记为睡眠状态，插入等待队列中
3. 退出临界区
4. 主动执行调度器开始等待
5. 进入临界区
6. 将自己从等待队列中移除
7. 退出临界区
8. 获得互斥锁

#### `cond_signal`

1. 进入临界区
2. 唤醒等待队列中第一个进程（如果有）
3. 退出临界区
4. 执行调度器

## 参考答案对比

由于注释非常详细，因此我的实现与参考答案没有出入。

## 总结

本实验中涉及到 OS 课程比较重要的知识点有：

* 线程同步与临界区
* 信号量、条件变量、管程的原理和实现
* 哲学家就餐问题

还有没有涉及到的知识点有：

* 死锁（challenge涉及简单的检测）
* 进程间通信（信号、管道、消息队列、共享内存）
* 读者-写者问题
