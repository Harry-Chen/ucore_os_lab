# uCore Lab3 实验报告

## 练习1：分配并初始化一个进程控制块

这个练习中要做的工作非常简单，只要对得到的 `proc_struct` 结构体进行初始化。先用 `memset` 全部置0，而后将有用的域（`state`, `pid`, `cr3`）手动赋值即可。

进程切换需要保存进程的上下文（包括通用寄存器、当前指令位置等），而 `proc_struct` 中的 `context` 和 `tf` 两个域就是用作此用途的。二者的不同是，`tf` 是线程在用户态执行时，由于异常/中断/系统调用等缘故，进入系统的中断服务程序时保存的中断帧，当进程需要跳回用户态时被使用；而 `context` 是线程在内核态执行时的上下文，用于进程的切换，被调度到的进程首先需要恢复 `context` 中的上下文。

## 练习2：为新创建的内核线程分配资源

这个练习中，需要实现进程的 `fork`，事实上，按照注释调用各个函数完成各项信息的获取与复制即可。首先需要注意的是，不能忘记为进程获取一个新的 `pid`；其次，对于各种错误（如分配进程控制块失败、分配内核栈失败、拷贝进程信息失败等），都需要进行恰当的处理（如释放实现分配的空间）。给出的代码中已经有提示，如有 `bad_fork_cleanup_kstack` 的标号，于是只要在相应错误发生时跳转过去即可。

uCore 的 PID 分配是依赖 `get_pid` 函数实现的，从它的注释中就可以看出对每次调用分配的 PID 都是唯一的。函数中，`next_safe` 表征最大可安全分配的 PID 上界，算法总是试图在这个上界内分配自增的 PID。起初，`next_safe` 是最大允许的进程数量 + 1，而当这些 PID 都用完以后，就需要重新计算 `next_safe`，将其更新为目前已分配到的 PID 后面最近的空闲区间上边界。这个算法保证了分配的 PID 永远是空闲的，所以当前运行的进程 PID 都是唯一的。同时，通过一个比较简单的 assert，能够保证 PID 数量总是小于进程数量，不会被彻底用完。

## 练习3：阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的

`proc_run` 函数在被调用时，首先判断是否为当前进程（避免无谓切换），而后关闭中断，并将 `TSS` 段中的 `ESP0` 更改为要运行的进程的内核栈顶，以让该进程之后的 trapframe 能够保存在属于自己的内核栈上。而后，向 `CR3` 寄存器中加载要下一进程的页表地址。最后，调用 `switch_to` 函数，保存当前进程的上下文，并装入下一进程的上下文，而后跳转到实际应该执行的地址。

本实验中创建了两个内核线程，分别是 `idleproc` 和 `initproc`，前者什么也不做，只是把自己的时间片让给别的进程（主动调用 `schedule`），后者在打印一些字符串以后退出。

`local_intr_save(intr_flag)` 用于屏蔽中断，并将原本的中断状态保存在 `intr_flag` 中，`local_intr_restore(intr_flag)` 则将中断使能状态恢复到 `intr_flag` 的状态。这两个语句能够在单处理器系统上形成一个临界区，保证其中的操作不会被（可屏蔽中断）打断。

## 参考答案对比

参考答案中，创建进程时，在获取 PID 和插入进程、增长计数的整个过程中关闭了中断，这是很有必要的，因为这些操作应当是连续的，如果允许中断，可能会发生不可预知的冲突。同时，我忘了将总进程数量 `nr_process` 自增。

其余的实现基本是一致的。

## 总结

本实验中涉及到 OS 课程比较重要的知识点有：

* 进程/线程的创建、管理
* 进程/线程的切换、（简单）调度

还有没有涉及到的知识点有：

* 不同特权级进程的切换
* 用户进程的创建和切换
